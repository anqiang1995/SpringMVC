<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.4.3">Jekyll</generator><link href="http://localhost:4000/SpringMVC/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/SpringMVC/" rel="alternate" type="text/html" /><updated>2017-04-07T16:03:14+08:00</updated><id>http://localhost:4000/SpringMVC/</id><title type="html">SpringMVC API入门教程</title><subtitle>技术支持：河北工业大学梦云智软件开发团队
</subtitle><entry><title type="html">第七节：更新数据 – 对接C层</title><link href="http://localhost:4000/SpringMVC/chapter2/7-update-to-controller/" rel="alternate" type="text/html" title="第七节：更新数据 -- 对接C层" /><published>2017-04-07T15:25:59+08:00</published><updated>2017-04-07T15:25:59+08:00</updated><id>http://localhost:4000/SpringMVC/chapter2/7-update-to-controller</id><content type="html" xml:base="http://localhost:4000/SpringMVC/chapter2/7-update-to-controller/">&lt;p&gt;以数据更新为例，在&lt;code class=&quot;highlighter-rouge&quot;&gt;SpringMVC&lt;/code&gt;的世界里，大体的操作是这样的：
&lt;img src=&quot;/SpringMVC/assets/image/chapter2/29.png&quot; alt=&quot;springmvc seq&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Spring&lt;/code&gt;为我们自动实现了&lt;code class=&quot;highlighter-rouge&quot;&gt;TeacherRepository&lt;/code&gt;接口，我们手动的实现了&lt;code class=&quot;highlighter-rouge&quot;&gt;TeacherService&lt;/code&gt;接口，并进行单元测试。在以上两个接口可用并测试的基础上，我们的C层所要做的工作就是，直接将数据转发给&lt;code class=&quot;highlighter-rouge&quot;&gt;service&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    // @PutMapping 表明该方法只接收 put 请求.
    @PutMapping(&quot;/{id}&quot;)
    public Teacher updateTeacher(@PathVariable Long id, @RequestBody Teacher teacher) throws EntityNotFoundException {
        // 数据转发
        return teacherService.saveTeacher(id, teacher);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;由于&lt;code class=&quot;highlighter-rouge&quot;&gt;teacherService&lt;/code&gt;在执行&lt;code class=&quot;highlighter-rouge&quot;&gt;saveTeacher&lt;/code&gt;时，可能会抛出一个异常。我们在这里，可以手动的使用&lt;code class=&quot;highlighter-rouge&quot;&gt;try catch&lt;/code&gt;来进行处理后，重新定制一个新的异常，返回给&lt;code class=&quot;highlighter-rouge&quot;&gt;spring&lt;/code&gt;，也可以在函数声明中，加入&lt;code class=&quot;highlighter-rouge&quot;&gt;throws EntityNotFoundException&lt;/code&gt;来直接抛出这个异常。在这里，我们直接将异常向上抛出。&lt;/p&gt;

&lt;p&gt;完整代码：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.mengyunzhi.controller;

import com.mengyunzhi.repository.Teacher;
import com.mengyunzhi.repository.TeacherRepository;
import com.mengyunzhi.service.TeacherService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import javax.persistence.EntityNotFoundException;
import javax.validation.Valid;

/**
 * Created by panjie on 17/4/6.
 */
// 声明为Rest控制器（支持前后台分离）
@RestController
@RequestMapping(&quot;/teacher&quot;)
public class TeacherController {
    @Autowired
    private TeacherRepository teacherRepository;

    @Autowired
    private TeacherService teacherService;

    // 设置路由
    @PostMapping(&quot;/save&quot;)
    // 使用@RequestBody注解，将请求的`json`数据，直接加载至teacher对象
    public Teacher saveTeacher(@Valid @RequestBody Teacher teacher) {
        // 打印加载的数据
        System.out.println(teacher);

        // 调用保存操作
        return teacherRepository.save(teacher);
    }

    // @GetMapping 表明该方法只接收 get 请求.
    // {id}即为url中传入教师关键字
    @GetMapping(&quot;/{id}&quot;)
    // @PathVariable 获取路由中的id值
    public Teacher getTeacherById(@PathVariable Long id) {
        return teacherRepository.findOne(id);
    }

    // @PutMapping 表明该方法只接收 put 请求.
    @PutMapping(&quot;/{id}&quot;)
    public Teacher updateTeacher(@PathVariable Long id, @RequestBody Teacher teacher) throws EntityNotFoundException {
        // 数据转发
        return teacherService.saveTeacher(id, teacher);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h2 id=&quot;测试&quot;&gt;测试&lt;/h2&gt;
&lt;p&gt;正确用例，略。
错误用例：
&lt;img src=&quot;/SpringMVC/assets/image/chapter2/30.png&quot; alt=&quot;update error unit test&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;作业&quot;&gt;作业&lt;/h2&gt;
&lt;p&gt;将数据增加与删除，由直接调用&lt;code class=&quot;highlighter-rouge&quot;&gt;repository&lt;/code&gt;改写为调用&lt;code class=&quot;highlighter-rouge&quot;&gt;service&lt;/code&gt;。&lt;/p&gt;</content><author><name>潘杰</name></author><summary type="html">以数据更新为例，在SpringMVC的世界里，大体的操作是这样的：</summary></entry><entry><title type="html">第七节：更新数据 – service</title><link href="http://localhost:4000/SpringMVC/chapter2/7-update-service/" rel="alternate" type="text/html" title="第七节：更新数据 -- service" /><published>2017-04-07T15:20:42+08:00</published><updated>2017-04-07T15:20:42+08:00</updated><id>http://localhost:4000/SpringMVC/chapter2/7-update-service</id><content type="html" xml:base="http://localhost:4000/SpringMVC/chapter2/7-update-service/">&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;SpringMVC&lt;/code&gt;中，&lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt;层更多在功能是：数据转发，数据验证，数据绑定，路由设定等。而不负责具体的数据的处理。显然的，我们上述代码的C层中，对数据进行逻辑处理。这违背了上述的原则。&lt;code class=&quot;highlighter-rouge&quot;&gt;SpringMVC&lt;/code&gt;中，&lt;code class=&quot;highlighter-rouge&quot;&gt;service&lt;/code&gt;层负责对进行逻辑运算及数据的处理。&lt;/p&gt;

&lt;p&gt;我们在使用&lt;code class=&quot;highlighter-rouge&quot;&gt;teacherRepository&lt;/code&gt;时，已经体验了&lt;code class=&quot;highlighter-rouge&quot;&gt;spring&lt;/code&gt;面向接口编程的魅力。和前面一样，在建立&lt;code class=&quot;highlighter-rouge&quot;&gt;service&lt;/code&gt;时，同样也是面向接口的。我们在其实类中引用的，也是接口，而非对象。&lt;/p&gt;

&lt;h2 id=&quot;建立接口&quot;&gt;建立接口&lt;/h2&gt;
&lt;p&gt;建立文件&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.mengyunzhi.service;

/**
 * Created by panjie on 17/4/7.
 */
public interface TeacherService {
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;建立方法&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.mengyunzhi.service;

import com.mengyunzhi.repository.Teacher;

/**
 * Created by panjie on 17/4/7.
 */
public interface TeacherService {
    /**
     * 保存
     * @param id 关键字
     * @param teacher 教师
     * @return 保存后的教师
     */
    Teacher saveTeacher(Long id, Teacher teacher);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;hr /&gt;

&lt;p&gt;声明抛出异常类型&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
import javax.persistence.EntityNotFoundException;
    ...
    Teacher saveTeacher(Long id, Teacher teacher) throws EntityNotFoundException;
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;实现接口&quot;&gt;实现接口&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/SpringMVC/assets/image/chapter2/2.gif&quot; alt=&quot;imp interface&quot; /&gt;&lt;/p&gt;

&lt;p&gt;没错，有了&lt;code class=&quot;highlighter-rouge&quot;&gt;IDEA&lt;/code&gt;一切操作就是如此的简单。如果再结合快捷键的话，相信还将是另一番天地。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;加入&lt;code class=&quot;highlighter-rouge&quot;&gt;Service&lt;/code&gt;注解&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Service            // 说明本类是一个Service，Spring在进行自动注入的时候，会将有此类注入到相应的TeacherService中。
public class TeacherServiceImpl implements TeacherService {
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;自动注入&lt;code class=&quot;highlighter-rouge&quot;&gt;TeacherRepository&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    @Autowired
    private TeacherRepository teacherRepository;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;实现数据更新&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    @Override
    public Teacher saveTeacher(Long id, Teacher teacher) throws EntityNotFoundException {
        // 判断是否存在该实体，如果不存在，则报错
        if (teacherRepository.findOne(id) == null) {
            throw new EntityNotFoundException(&quot;传入的ID值：&quot; + id.toString() + &quot;有误。未找到对应的实体&quot;);
        }

        // 对实体ID赋值, 并执行更新操作
        teacher.setId(id);
        return teacherRepository.save(teacher);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;单元测试&quot;&gt;单元测试&lt;/h2&gt;
&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;test&lt;/code&gt;文件夹中，新建对应的测试类，进行单元测试。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/SpringMVC/assets/image/chapter2/26.png&quot; alt=&quot;new unit test&quot; /&gt;&lt;/p&gt;

&lt;p&gt;增加单元测试注解&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@RunWith(SpringRunner.class)
@SpringBootTest
public class TeacherServiceImplTest {
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;hr /&gt;

&lt;p&gt;编写测试方法:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    @Test
    public void saveTeacherTest() {
        // 实例化教师 李四
       
        // 保存李四至数据库
        
        // 打印李四的数据

        // 实例化教师 张三
       
        // 将张三的数据更新到原李四的数据中

        // 查询并打印更新后的数据
        
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;代码实现：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    @Test
    public void saveTeacherTest() {
        // 实例化教师 李四
        Teacher teacherLisi = new Teacher(&quot;lisi&quot;,
                &quot;lisi@email.com&quot;,
                &quot;scse of hebut&quot;,
                false);

        // 保存李四至数据库
        teacherLisi = teacherRepository.save(teacherLisi);

        // 打印李四的数据
        System.out.println(teacherLisi);

        // 实例化教师 张三
        Teacher teacherZhangsan = new Teacher(
                &quot;zhangsan&quot;,
                &quot;zhangsan@yunzhiclub.com&quot;,
                &quot;scse of hebut&quot;,
                true);

        // 将张三的数据更新到原李四的数据中
        Teacher newTeacher = teacherService.saveTeacher(teacherLisi.getId(), teacherZhangsan);

        // 查询并打印更新后的数据
        System.out.println(newTeacher);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;在代码实现中，我们使用到了&lt;code class=&quot;highlighter-rouge&quot;&gt;teacherRepository&lt;/code&gt;及&lt;code class=&quot;highlighter-rouge&quot;&gt;teacherService&lt;/code&gt;, 这两个对象也是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;@Autowired&lt;/code&gt;来由&lt;code class=&quot;highlighter-rouge&quot;&gt;Spring&lt;/code&gt;完成的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;完整代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.mengyunzhi.service;

import com.mengyunzhi.repository.Teacher;
import com.mengyunzhi.repository.TeacherRepository;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;

/**
 * Created by panjie on 17/4/7.
 */
@RunWith(SpringRunner.class)
@SpringBootTest
public class TeacherServiceImplTest {
    @Autowired
    private TeacherService teacherService;
    @Autowired
    private TeacherRepository teacherRepository;

    @Test
    public void saveTeacherTest() {
        // 实例化教师 李四
        Teacher teacherLisi = new Teacher(&quot;lisi&quot;,
                &quot;lisi@email.com&quot;,
                &quot;scse of hebut&quot;,
                false);

        // 保存李四至数据库
        teacherLisi = teacherRepository.save(teacherLisi);

        // 打印李四的数据
        System.out.println(teacherLisi);

        // 实例化教师 张三
        Teacher teacherZhangsan = new Teacher(
                &quot;zhangsan&quot;,
                &quot;zhangsan@yunzhiclub.com&quot;,
                &quot;scse of hebut&quot;,
                true);

        // 将张三的数据更新到原李四的数据中
        Teacher newTeacher = teacherService.saveTeacher(teacherLisi.getId(), teacherZhangsan);

        // 查询并打印更新后的数据
        System.out.println(newTeacher);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们点击方法前面的绿色启动按钮，来启动单元测试，最终将在控制台得到如下信息：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Hibernate: insert into teacher (address, email, name, sex) values (?, ?, ?, ?)
Teacher{id=1, name='lisi', email='lisi@email.com', address='scse of hebut', sex=false}
Hibernate: select teacher0_.id as id1_0_0_, teacher0_.address as address2_0_0_, teacher0_.email as email3_0_0_, teacher0_.name as name4_0_0_, teacher0_.sex as sex5_0_0_ from teacher teacher0_ where teacher0_.id=?
Hibernate: select teacher0_.id as id1_0_0_, teacher0_.address as address2_0_0_, teacher0_.email as email3_0_0_, teacher0_.name as name4_0_0_, teacher0_.sex as sex5_0_0_ from teacher teacher0_ where teacher0_.id=?
Hibernate: update teacher set address=?, email=?, name=?, sex=? where id=?
Teacher{id=1, name='zhangsan', email='zhangsan@yunzhiclub.com', address='scse of hebut', sex=true}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;其中，有&lt;code class=&quot;highlighter-rouge&quot;&gt;Hibernate: &lt;/code&gt;前缀的，为&lt;code class=&quot;highlighter-rouge&quot;&gt;Hibernate&lt;/code&gt;生成的数据库操作语句。
通过观察，我们不难发现，先后进行数据的插入、更新操作。&lt;/p&gt;

&lt;h2 id=&quot;完善测试&quot;&gt;完善测试&lt;/h2&gt;
&lt;p&gt;有了正确的用例，我们也需要错误的用例。
新建方法，并加入注释：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    /**
     * 更新的数据不存在于数据表中时，发生错误，并抛出异常
     */
    @Test
    public void saveTeacherErrorTest() {
        // 指定id为0

        // 实例化教师张三

        // 使用张三的数据来更新0号教师的数据
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;代码实现：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    /**
     * 更新的数据不存在于数据表中时，发生错误，并抛出异常
     */
    @Test
    public void saveTeacherErrorTest() {
        // 指定id为0
        Long id = 0L;

        // 实例化教师张三
        Teacher teacherZhangsan = new Teacher(
                &quot;zhangsan&quot;,
                &quot;zhangsan@yunzhiclub.com&quot;,
                &quot;scse of hebut&quot;,
                true);

        // 使用张三的数据来更新0号教师的数据
        teacherService.saveTeacher(id, teacherZhangsan);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;测试用例：
&lt;img src=&quot;/SpringMVC/assets/image/chapter2/27.png&quot; alt=&quot;update error unit test&quot; /&gt;&lt;/p&gt;

&lt;p&gt;虽然这样达到了我们测试的目的，但从单元测试的规范上讲，红色代表测试发生异常，绿色才是我们想看到的。为此，我们为&lt;code class=&quot;highlighter-rouge&quot;&gt;@Test&lt;/code&gt;指定一个参数，进而表明，此测试方法的期待结果是获取一个&lt;code class=&quot;highlighter-rouge&quot;&gt;EntityNotFoundException&lt;/code&gt;类型的异常。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    @Test(expected = EntityNotFoundException.class)
    public void saveTeacherErrorTest() {
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;此时，当我们再次进行测试时，发现控制台没有报告异常，而且测试结果显示为绿色，表示测试通过。
&lt;img src=&quot;/SpringMVC/assets/image/chapter2/28.png&quot; alt=&quot;update error unit test&quot; /&gt;&lt;/p&gt;

&lt;p&gt;完整代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.mengyunzhi.service;

import com.mengyunzhi.repository.Teacher;
import com.mengyunzhi.repository.TeacherRepository;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;

import javax.persistence.EntityNotFoundException;

/**
 * Created by panjie on 17/4/7.
 */
@RunWith(SpringRunner.class)
@SpringBootTest
public class TeacherServiceImplTest {
    @Autowired
    private TeacherService teacherService;
    @Autowired
    private TeacherRepository teacherRepository;

    @Test
    public void saveTeacherTest() {
        // 实例化教师 李四
        Teacher teacherLisi = new Teacher(&quot;lisi&quot;,
                &quot;lisi@email.com&quot;,
                &quot;scse of hebut&quot;,
                false);

        // 保存李四至数据库
        teacherLisi = teacherRepository.save(teacherLisi);

        // 打印李四的数据
        System.out.println(teacherLisi);

        // 实例化教师 张三
        Teacher teacherZhangsan = new Teacher(
                &quot;zhangsan&quot;,
                &quot;zhangsan@yunzhiclub.com&quot;,
                &quot;scse of hebut&quot;,
                true);

        // 将张三的数据更新到原李四的数据中
        Teacher newTeacher = teacherService.saveTeacher(teacherLisi.getId(), teacherZhangsan);

        // 查询并打印更新后的数据
        System.out.println(newTeacher);
    }

    /**
     * 更新的数据不存在于数据表中时，发生错误，并抛出异常
     */
    @Test(expected = EntityNotFoundException.class)     // 此方法的预期结果是获取到一个EntityNotFoundException异常
    public void saveTeacherErrorTest() {
        // 指定id为0
        Long id = 0L;

        // 实例化教师张三
        Teacher teacherZhangsan = new Teacher(
                &quot;zhangsan&quot;,
                &quot;zhangsan@yunzhiclub.com&quot;,
                &quot;scse of hebut&quot;,
                true);

        // 使用张三的数据来更新0号教师的数据
        teacherService.saveTeacher(id, teacherZhangsan);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;单元测试参考文档：&lt;a href=&quot;http://wiki.jikexueyuan.com/project/junit/exceptions-test.html&quot;&gt;http://wiki.jikexueyuan.com/project/junit/exceptions-test.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>潘杰</name></author><summary type="html">在SpringMVC中，C层更多在功能是：数据转发，数据验证，数据绑定，路由设定等。而不负责具体的数据的处理。显然的，我们上述代码的C层中，对数据进行逻辑处理。这违背了上述的原则。SpringMVC中，service层负责对进行逻辑运算及数据的处理。</summary></entry><entry><title type="html">第七节：更新数据 – update</title><link href="http://localhost:4000/SpringMVC/chapter2/7-update/" rel="alternate" type="text/html" title="第七节：更新数据 -- update" /><published>2017-04-07T08:50:55+08:00</published><updated>2017-04-07T08:50:55+08:00</updated><id>http://localhost:4000/SpringMVC/chapter2/7-update</id><content type="html" xml:base="http://localhost:4000/SpringMVC/chapter2/7-update/">&lt;p&gt;和其它框架一样，在数据更新中，&lt;code class=&quot;highlighter-rouge&quot;&gt;SpringMVC&lt;/code&gt;调用的方法同&lt;code class=&quot;highlighter-rouge&quot;&gt;Create&lt;/code&gt;，即均为&lt;code class=&quot;highlighter-rouge&quot;&gt;save()&lt;/code&gt;方法。则按照前面章节的思想，我们不难写出如下数据更新的代码。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    // @PutMapping 表明该方法只接收 put 请求.
    @PutMapping(&quot;/{id}&quot;)
    public Teacher updateTeacher(@PathVariable Long id, @RequestBody Teacher teacher) {
        // 对实体ID赋值, 并执行更新操作
        teacher.setId(id);
        return teacherRepository.save(teacher);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里，我们使用了&lt;code class=&quot;highlighter-rouge&quot;&gt;put&lt;/code&gt;方法，其实和&lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;post&lt;/code&gt;一样，这仅仅是一个请求的方法而已。除了&lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;post&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;put&lt;/code&gt;方法外，我们还会接触到&lt;code class=&quot;highlighter-rouge&quot;&gt;patch&lt;/code&gt;及&lt;code class=&quot;highlighter-rouge&quot;&gt;delete&lt;/code&gt;方法。
我们简单做个汇总：&lt;/p&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;th&gt;方法名&lt;/th&gt;
        &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;get&lt;/td&gt;
        &lt;td&gt;用于数据的查询操作&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;post&lt;/td&gt;
        &lt;td&gt;用于数据的新增操作&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;put&lt;/td&gt;
        &lt;td&gt;用于数据的更新操作（更新实体的全部字段）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;patch&lt;/td&gt;
        &lt;td&gt;用于数据的更新操作（更新实体的部分字段）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;delete&lt;/td&gt;
        &lt;td&gt;用于数据的删除操作&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

&lt;h2 id=&quot;测试&quot;&gt;测试&lt;/h2&gt;
&lt;p&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;read&lt;/code&gt;操作相同，我们在进行数据的更新前，需要先新增一个实体。然后再对这个实体进行修改。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/SpringMVC/assets/image/chapter2/1.gif&quot; alt=&quot;update&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;完善代码&quot;&gt;完善代码&lt;/h1&gt;
&lt;p&gt;我们看到，我们新增了一个教师，然后进行查询得到了这个教师的数据，再进行修改，然后再查询，发现教师的数据的确被我们修改了。&lt;/p&gt;

&lt;p&gt;不过，如果我们测试充分的话，也会很容易的发现：在数据修改的过程中，如果并不存在我们要修改的数据，那么则会自动的新增一条记录。而这，并不是我们想看到的。我们想要的结果是，如果有这条记录，则更新，如果没有，则提示我们不存在该条记录。&lt;/p&gt;

&lt;p&gt;完善代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    // @PutMapping 表明该方法只接收 put 请求.
    @PutMapping(&quot;/{id}&quot;)
    public Teacher updateTeacher(@PathVariable Long id, @RequestBody Teacher teacher) throws EntityNotFoundException {
        // 判断是否存在该实体，如果不存在，则报错
        if (teacherRepository.findOne(id) == null) {
            throw new EntityNotFoundException(&quot;传入的ID值：&quot; + id.toString() + &quot;有误。未找到对应的实体&quot;);
        }

        // 对实体ID赋值, 并执行更新操作
        teacher.setId(id);
        return teacherRepository.save(teacher);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;增加了传入&lt;code class=&quot;highlighter-rouge&quot;&gt;id&lt;/code&gt;是否对应实体的判断, 如果没有找到，则抛出一个&lt;code class=&quot;highlighter-rouge&quot;&gt;javax.persistence.EntityNotFoundException&lt;/code&gt;异常。同时，。&lt;/li&gt;
  &lt;li&gt;在函数定义时，增加了&lt;code class=&quot;highlighter-rouge&quot;&gt;throws EntityNotFoundException&lt;/code&gt;来声明抛出的异常类型。该异常能够被&lt;code class=&quot;highlighter-rouge&quot;&gt;SpringMVC&lt;/code&gt;捕获，并且转化为&lt;code class=&quot;highlighter-rouge&quot;&gt;json&lt;/code&gt;格式的报错信息进行输出&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们输入一个并不存在实体&lt;code class=&quot;highlighter-rouge&quot;&gt;id&lt;/code&gt;并进行测试，将得到如下提示信息：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/SpringMVC/assets/image/chapter2/25.png&quot; alt=&quot;entity not found exception&quot; /&gt;&lt;/p&gt;

&lt;p&gt;除此以外，根据具体的实际情况，我们还可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;SpringMVC&lt;/code&gt;为我们准备好的其它异常类型，比如&lt;code class=&quot;highlighter-rouge&quot;&gt;BindException&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;ConversionNotSupportedException&lt;/code&gt;等等。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;参考官方文档：&lt;a href=&quot;https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#mvc-ann-rest-spring-mvc-exceptions&quot;&gt;https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#mvc-ann-rest-spring-mvc-exceptions&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;完整代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.mengyunzhi.controller;

import com.mengyunzhi.repository.Teacher;
import com.mengyunzhi.repository.TeacherRepository;
import com.mengyunzhi.service.TeacherService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import javax.persistence.EntityNotFoundException;
import javax.validation.Valid;

/**
 * Created by panjie on 17/4/6.
 */
// 声明为Rest控制器（支持前后台分离）
@RestController
@RequestMapping(&quot;/teacher&quot;)
public class TeacherController {
    @Autowired
    private TeacherRepository teacherRepository;

    @Autowired
    private TeacherService teacherService;

    // 设置路由
    @PostMapping(&quot;/save&quot;)
    // 使用@RequestBody注解，将请求的`json`数据，直接加载至teacher对象
    public Teacher saveTeacher(@Valid @RequestBody Teacher teacher) {
        // 打印加载的数据
        System.out.println(teacher);

        // 调用保存操作
        return teacherRepository.save(teacher);
    }

    // @GetMapping 表明该方法只接收 get 请求.
    // {id}即为url中传入教师关键字
    @GetMapping(&quot;/{id}&quot;)
    // @PathVariable 获取路由中的id值
    public Teacher getTeacherById(@PathVariable Long id) {
        return teacherRepository.findOne(id);
    }

    // @PutMapping 表明该方法只接收 put 请求.
    @PutMapping(&quot;/{id}&quot;)
    public Teacher updateTeacher(@PathVariable Long id, @RequestBody Teacher teacher) throws EntityNotFoundException {
        // 判断是否存在该实体，如果不存在，则报错
        if (teacherRepository.findOne(id) == null) {
            throw new EntityNotFoundException(&quot;传入的ID值：&quot; + id.toString() + &quot;有误。未找到对应的实体&quot;);
        }

        // 对实体ID赋值, 并执行更新操作
        teacher.setId(id);
        return teacherRepository.save(teacher);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</content><author><name>潘杰</name></author><summary type="html">和其它框架一样，在数据更新中，SpringMVC调用的方法同Create，即均为save()方法。则按照前面章节的思想，我们不难写出如下数据更新的代码。 // @PutMapping 表明该方法只接收 put 请求. @PutMapping(&quot;/{id}&quot;) public Teacher updateTeacher(@PathVariable Long id, @RequestBody Teacher teacher) { // 对实体ID赋值, 并执行更新操作 teacher.setId(id); return teacherRepository.save(teacher); }</summary></entry><entry><title type="html">第六节：读取数据 – read</title><link href="http://localhost:4000/SpringMVC/chapter2/6-read/" rel="alternate" type="text/html" title="第六节：读取数据 -- read" /><published>2017-04-06T13:34:07+08:00</published><updated>2017-04-06T13:34:07+08:00</updated><id>http://localhost:4000/SpringMVC/chapter2/6-read</id><content type="html" xml:base="http://localhost:4000/SpringMVC/chapter2/6-read/">&lt;p&gt;在上节中，我们给出了参考的官方文档，并且新建了接口。本节中，仍然使用上节中给出参考文档中提及到的方法，使用&lt;code class=&quot;highlighter-rouge&quot;&gt;TeacherRepository&lt;/code&gt;来实现数据的读取。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;[说明]&lt;/strong&gt;  由于在上节中，新建&lt;code class=&quot;highlighter-rouge&quot;&gt;TeacherRepository&lt;/code&gt;时，已经进行过测试操作，本节再次使用该接口时，则可以直接跳过单元测试的内容。在实际的开发中也是这样的，如果该类是由你创建的，你需要对自己创建的类负责，必须进行相关的测试操作也保证类的可靠性。而如果类不是我们自己创建的，则假设该类经过了单元测试，并且可以直接被我们调用。&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;c层对接&quot;&gt;C层对接&lt;/h1&gt;
&lt;p&gt;在进行正式的对接前，我们首先要制定相关的API规范，即接收的数据都有什么，又期待返回什么样的数据。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;接收教师ID&lt;/li&gt;
  &lt;li&gt;返回该ID对应的教师实体&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面，我们按上述的说明，对&lt;code class=&quot;highlighter-rouge&quot;&gt;TeacherController&lt;/code&gt;类进行如下补充:&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;新建方法&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public Teacher getTeacherById() {
        
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;hr /&gt;

&lt;p&gt;添加路由&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    // @GetMapping 表明该方法只接收 get 请求.
    // {id}即为url中传入教师关键字
    @GetMapping(&quot;/teacher/{id}&quot;)
    public Teacher getTeacherById() {

    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;hr /&gt;

&lt;p&gt;添加接收参数&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    // @GetMapping 表明该方法只接收 get 请求.
    // {id}即为url中传入教师关键字
    @GetMapping(&quot;/teacher/{id}&quot;)
    // @PathVariable 获取路由中的id值
    public Teacher getTeacherById(@PathVariable Long id) {

    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;hr /&gt;

&lt;p&gt;获取教师实体并返回&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    // @GetMapping 表明该方法只接收 get 请求.
    // {id}即为url中传入教师关键字
    @GetMapping(&quot;/teacher/{id}&quot;)
    // @PathVariable 获取路由中的id值
    public Teacher getTeacherById(@PathVariable Long id) {  
        return teacherRepository.findOne(id);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;测试&quot;&gt;测试&lt;/h2&gt;
&lt;p&gt;启动项目及MySQL数据库服务，并启动postMan对上述方法进行测试.&lt;/p&gt;

&lt;h3 id=&quot;添加一条数据&quot;&gt;添加一条数据&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/SpringMVC/assets/image/chapter2/21.png&quot; alt=&quot;add data&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;查询刚刚添加的数据&quot;&gt;查询刚刚添加的数据&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/SpringMVC/assets/image/chapter2/22.png&quot; alt=&quot;find data&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;查询不存在的数据&quot;&gt;查询不存在的数据&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/SpringMVC/assets/image/chapter2/22.png&quot; alt=&quot;find not exist data&quot; /&gt;&lt;/p&gt;

&lt;p&gt;完事代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.mengyunzhi.controller;

import com.mengyunzhi.repository.Teacher;
import com.mengyunzhi.repository.TeacherRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import javax.validation.Valid;

/**
 * Created by panjie on 17/4/6.
 */
// 声明为Rest控制器（支持前后台分离）
@RestController
public class TeacherController {
    @Autowired
    private TeacherRepository teacherRepository;

    // 设置路由
    @RequestMapping(&quot;/teacher/save&quot;)
    // 使用@RequestBody注解，将请求的`json`数据，直接加载至teacher对象
    public Teacher saveTeacher(@Valid @RequestBody Teacher teacher) {
        // 打印加载的数据
        System.out.println(teacher);

        // 调用保存操作
        return teacherRepository.save(teacher);
    }

    // @GetMapping 表明该方法只接收 get 请求.
    // {id}即为url中传入教师关键字
    @GetMapping(&quot;/teacher/{id}&quot;)
    // @PathVariable 获取路由中的id值
    public Teacher getTeacherById(@PathVariable Long id) {
        return teacherRepository.findOne(id);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;重构&quot;&gt;重构&lt;/h1&gt;
&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;TeacherController&lt;/code&gt;中，我们定义了两处路由，都有&lt;code class=&quot;highlighter-rouge&quot;&gt;/teacher&lt;/code&gt;字符串，下面，我们通过对类添加路由的方式来进行重构，以降低代码的冗余。同时，更加明确的指定请求方式。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
@RestController
@RequestMapping(&quot;/teacher&quot;)
public class TeacherController {
    ...
    @PostMapping(&quot;/save&quot;)
    ...
    @GetMapping(&quot;/{id}&quot;)
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;完整代码：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.mengyunzhi.controller;

import com.mengyunzhi.repository.Teacher;
import com.mengyunzhi.repository.TeacherRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import javax.validation.Valid;

/**
 * Created by panjie on 17/4/6.
 */
// 声明为Rest控制器（支持前后台分离）
@RestController
@RequestMapping(&quot;/teacher&quot;)
public class TeacherController {
    @Autowired
    private TeacherRepository teacherRepository;

    // 设置路由
    @PostMapping(&quot;/save&quot;)
    // 使用@RequestBody注解，将请求的`json`数据，直接加载至teacher对象
    public Teacher saveTeacher(@Valid @RequestBody Teacher teacher) {
        // 打印加载的数据
        System.out.println(teacher);

        // 调用保存操作
        return teacherRepository.save(teacher);
    }

    // @GetMapping 表明该方法只接收 get 请求.
    // {id}即为url中传入教师关键字
    @GetMapping(&quot;/{id}&quot;)
    // @PathVariable 获取路由中的id值
    public Teacher getTeacherById(@PathVariable Long id) {
        return teacherRepository.findOne(id);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;参考官方文档：&lt;a href=&quot;http://docs.spring.io/spring-data/jpa/docs/1.11.1.RELEASE/reference/html/#repositories.core-concepts&quot;&gt;http://docs.spring.io/spring-data/jpa/docs/1.11.1.RELEASE/reference/html/#repositories.core-concepts&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;如果你感觉很轻松的就学习完了本节内容，那么说明你的基础打的比较牢固，具有很好的学习精神，具备了一定的英文阅读能力。恭喜你，在计算机工程的道路上，你将越走越加平坦。&lt;/p&gt;</content><author><name>潘杰</name></author><summary type="html">在上节中，我们给出了参考的官方文档，并且新建了接口。本节中，仍然使用上节中给出参考文档中提及到的方法，使用TeacherRepository来实现数据的读取。</summary></entry><entry><title type="html">第五节：数据验证</title><link href="http://localhost:4000/SpringMVC/chapter2/5-validate/" rel="alternate" type="text/html" title="第五节：数据验证" /><published>2017-04-06T13:33:17+08:00</published><updated>2017-04-06T13:33:17+08:00</updated><id>http://localhost:4000/SpringMVC/chapter2/5-validate</id><content type="html" xml:base="http://localhost:4000/SpringMVC/chapter2/5-validate/">&lt;p&gt;有数据输入，就必然涉及到数据的验证以及数据验证失败后的处理。本节中，让我们共同学习&lt;code class=&quot;highlighter-rouge&quot;&gt;SpringMVC&lt;/code&gt;是如何进行数据验证的。&lt;/p&gt;

&lt;p&gt;通过上节的学习，我们得知，&lt;code class=&quot;highlighter-rouge&quot;&gt;SpringMVC&lt;/code&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;@RequestBody&lt;/code&gt;注解将请求数据绑定到相应的实体中(对象)。数据绑定，其实是利用实体的&lt;code class=&quot;highlighter-rouge&quot;&gt;set&lt;/code&gt;方法进行了赋值的过程。数据的验证的过程我们也放置于此。&lt;/p&gt;

&lt;p&gt;我们找到&lt;code class=&quot;highlighter-rouge&quot;&gt;Teacher&lt;/code&gt;实体，使用注解的方法设置如下验证规则:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    @Column(length = 25)            // 声明字段的长度为25
    @Size(min = 2, max = 25)        // 最小长度为2（不能为空），最大长度为25
    private String name = &quot;&quot;;       // 姓名

    @Column(length = 50)
    @NotNull                        // 此列不能为空
    @Email                          // 邮箱验证
    @Size(max = 50)                 // 最大长度为50
    private String email = &quot;&quot;;      // 邮箱

    @Size(max = 255)                // 最大长度为255
    private String address = &quot;&quot;;    // 地址. 不进行@Column声明，则默认长度为255

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;完整代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.mengyunzhi.repository;


import org.hibernate.validator.constraints.Email;

import javax.persistence.*;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;

/**
 * Created by panjie on 17/4/5.
 */
// 使用@Entity 来说明该类对应一个数据表
@Entity
public class Teacher {
    //    声明主键
    @Id
    //    声明主键生成策略为 自动
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;

    @Column(length = 25)            // 声明字段的长度为25
    @Size(min = 2, max = 25)        // 最小长度为2（不能为空），最大长度为25
    private String name = &quot;&quot;;       // 姓名

    @Column(length = 50)
    @NotNull                        // 此列不能为空
    @Email                          // 邮箱验证
    @Size(max = 50)                 // 最大长度为50
    private String email = &quot;&quot;;      // 邮箱

    @Size(max = 255)                // 最大长度为255
    private String address = &quot;&quot;;    // 地址. 不进行@Column声明，则默认长度为255

    private Boolean sex = false;    // 性别：false(0)，男。true(1)，女.

    public void setId(Long id) {
        this.id = id;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    public void setSex(Boolean sex) {
        this.sex = sex;
    }

    public Long getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String getEmail() {
        return email;
    }

    public String getAddress() {
        return address;
    }

    public Boolean getSex() {
        return sex;
    }

    public Teacher(String name, String email, String address, Boolean sex) {
        this.name = name;
        this.email = email;
        this.address = address;
        this.sex = sex;
    }

    public Teacher() {
    }

    @Override
    public String toString() {
        return &quot;Teacher{&quot; +
                &quot;id=&quot; + id +
                &quot;, name='&quot; + name + '\'' +
                &quot;, email='&quot; + email + '\'' +
                &quot;, address='&quot; + address + '\'' +
                &quot;, sex=&quot; + sex +
                '}';
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;重新启动应用:&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;正常数据:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/SpringMVC/assets/image/chapter2/17.png&quot; alt=&quot;validate&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;姓名过短:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/SpringMVC/assets/image/chapter2/18.png&quot; alt=&quot;validate name&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;邮箱格式不合法:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/SpringMVC/assets/image/chapter2/19.png&quot; alt=&quot;validate email&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其它的自行验证一下吧。&lt;/p&gt;

&lt;h2 id=&quot;格式化验证错误信息&quot;&gt;格式化验证错误信息&lt;/h2&gt;
&lt;p&gt;前面，我们虽然得到了错误的验证信息，但是错误的信息全部在&lt;code class=&quot;highlighter-rouge&quot;&gt;message&lt;/code&gt;字段中，这无疑为我们前台排错增加了一定的难度。&lt;code class=&quot;highlighter-rouge&quot;&gt;SpringMVC&lt;/code&gt;当然想到了这点。
我们打开&lt;code class=&quot;highlighter-rouge&quot;&gt;TeacherController&lt;/code&gt;控制器，为&lt;code class=&quot;highlighter-rouge&quot;&gt;saveTeacher&lt;/code&gt;方法增加一个&lt;code class=&quot;highlighter-rouge&quot;&gt;@Valid&lt;/code&gt;注解，并重新启动应用。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    ...
    public Teacher saveTeacher(@Valid @RequestBody Teacher teacher) {
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;该注解位于：javax.validation.Valid;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;此时，当我们再次发送一些数据而未验证成功时，将得到如下的错误信息:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/SpringMVC/assets/image/chapter2/20.png&quot; alt=&quot;validate format&quot; /&gt;&lt;/p&gt;

&lt;p&gt;没错，这就是我们想要的。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;参考官方文档：
&lt;a href=&quot;https://spring.io/guides/gs/validating-form-input/&quot;&gt;https://spring.io/guides/gs/validating-form-input/&lt;/a&gt;
&lt;a href=&quot;http://hibernate.org/validator/&quot;&gt;http://hibernate.org/validator/&lt;/a&gt; &lt;a href=&quot;https://www.ibm.com/developerworks/cn/java/j-lo-jsr303/&quot;&gt;https://www.ibm.com/developerworks/cn/java/j-lo-jsr303/&lt;/a&gt; &lt;a href=&quot;https://docs.spring.io/spring/docs/current/spring-framework-reference/html/validation.html&quot;&gt;https://docs.spring.io/spring/docs/current/spring-framework-reference/html/validation.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>潘杰</name></author><summary type="html">有数据输入，就必然涉及到数据的验证以及数据验证失败后的处理。本节中，让我们共同学习SpringMVC是如何进行数据验证的。</summary></entry><entry><title type="html">第四节：增加数据 – create</title><link href="http://localhost:4000/SpringMVC/chapter2/4-create/" rel="alternate" type="text/html" title="第四节：增加数据 -- create" /><published>2017-04-06T08:08:09+08:00</published><updated>2017-04-06T08:08:09+08:00</updated><id>http://localhost:4000/SpringMVC/chapter2/4-create</id><content type="html" xml:base="http://localhost:4000/SpringMVC/chapter2/4-create/">&lt;p&gt;和我们以前学习的框架基本一致，框架已经为我们封装好了大部分的基本操作，我们只需要做适当的继承操作就可以实现大部的数据操作了。&lt;/p&gt;

&lt;h1 id=&quot;crudrepository&quot;&gt;CrudRepository&lt;/h1&gt;
&lt;p&gt;在SpringMVC中，为我提供了用于进行数据增查删改删的&lt;code class=&quot;highlighter-rouge&quot;&gt;CrudRepository&lt;/code&gt;接口。下面，我们来新建第一个用于数据表操作的接口文件 – &lt;code class=&quot;highlighter-rouge&quot;&gt;TeacherRepository&lt;/code&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;没错，是&lt;code class=&quot;highlighter-rouge&quot;&gt;接口&lt;/code&gt;，而不是&lt;code class=&quot;highlighter-rouge&quot;&gt;类&lt;/code&gt;。&lt;code class=&quot;highlighter-rouge&quot;&gt;SpringMVC&lt;/code&gt;做自动的为我们的接口做相关的实现。而我们并不需要关心&lt;code class=&quot;highlighter-rouge&quot;&gt;Spring&lt;/code&gt;是怎么做到的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/SpringMVC/assets/image/chapter2/9.png&quot; alt=&quot;TeacherRepository&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.mengyunzhi.repository;

import org.springframework.data.repository.CrudRepository;

/**
 * Created by panjie on 17/4/6.
 */
public interface TeacherRepository extends CrudRepository&amp;lt;Teacher, Long&amp;gt; {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;测试&quot;&gt;测试&lt;/h2&gt;
&lt;p&gt;我们在&lt;code class=&quot;highlighter-rouge&quot;&gt;test&lt;/code&gt;文件夹中的同名位置上新建对应的测试类。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/SpringMVC/assets/image/chapter2/10.png&quot; alt=&quot;TeacherRepositoryTest&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.mengyunzhi.repository;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;

/**
 * Created by panjie on 17/4/6.
 */
// 使用以下两个注解来说明：本测试类基于SpringBoot。(必须)
@RunWith(SpringRunner.class)
@SpringBootTest
public class TeacherRepositoryTest {
    // @Autowired注解：自动加载Spring为我们自动实例化的实现了TeacherRepository接口的对象
    @Autowired
    private TeacherRepository teacherRepository;

    // @Test：本方法为一个单元测试方法
    @Test
    public void addTeacher() {
        // 执行数据保存操作
        teacherRepository.save(new Teacher());

        // 打印Spring为我们自动实例化的对象
        System.out.println(teacherRepository);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后我们点击方法前面的&lt;code class=&quot;highlighter-rouge&quot;&gt;Run Test&lt;/code&gt;小图标&lt;img src=&quot;/SpringMVC/assets/image/chapter2/11.png&quot; alt=&quot;run test&quot; /&gt;
来启动单元测试。&lt;/p&gt;

&lt;p&gt;我们将在控制台，得到如下信息：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;org.springframework.data.jpa.repository.support.SimpleJpaRepository@340cb97f
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;没错，这就是&lt;code class=&quot;highlighter-rouge&quot;&gt;Spring&lt;/code&gt;自动实例化的&lt;code class=&quot;highlighter-rouge&quot;&gt;teacherRepository&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;此时，我们使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Navicat&lt;/code&gt;，打开数据表，发现里面已经成功的增加了一条数据。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/SpringMVC/assets/image/chapter2/12.png&quot; alt=&quot;add data&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在实际的开发过程中，每新增一条数据，都去数据表中进行查看，效率还是比较低的。我们还可以通过修改配置文件的方法，来直接输出&lt;code class=&quot;highlighter-rouge&quot;&gt;sql&lt;/code&gt;语句，来查看是否执行了我们想要的操作。&lt;/p&gt;

&lt;p&gt;在配置文件中，增加一行:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 显示SQL语句
spring.jpa.show-sql=true
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;增加后，整体配置文件如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 在项目初始化时，重新创建数据表
spring.jpa.hibernate.ddl-auto=create
# 指定连接的类型为mysql 连接的地址为：localhost 端口为3306 ，数据为springmvc
spring.datasource.url=jdbc:mysql://localhost:3306/springmvc
# 用户名为root
spring.datasource.username=root
# 密码为空
spring.datasource.password=
# 显示SQL语句
spring.jpa.show-sql=true
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;此时，当我们再次&lt;code class=&quot;highlighter-rouge&quot;&gt;Run Test&lt;/code&gt;的时候，在控制台中，将得到如下信息:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Hibernate: insert into teacher (address, email, name, sex) values (?, ?, ?, ?)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;当我们看到这条语句时，就可以放心的认为：数据文件已经成功的插入到数据表中了。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;参考官方文档：&lt;a href=&quot;http://docs.spring.io/spring-data/jpa/docs/1.11.1.RELEASE/reference/html/#repositories.core-concepts&quot;&gt;http://docs.spring.io/spring-data/jpa/docs/1.11.1.RELEASE/reference/html/#repositories.core-concepts&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;对接c层&quot;&gt;对接C层&lt;/h1&gt;
&lt;p&gt;有了上面的测试代码，C层对接起来，也相应的容易的多了。但对接以前，我们需要做了解以下几点。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;数据发送请求的方式为&lt;code class=&quot;highlighter-rouge&quot;&gt;post&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;数据以&lt;code class=&quot;highlighter-rouge&quot;&gt;json&lt;/code&gt;的格式进行发送。&lt;/li&gt;
  &lt;li&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;json&lt;/code&gt;数据中，发送新增教师的姓名、地址、邮箱、性别信息。&lt;/li&gt;
  &lt;li&gt;除性别的变量类型是&lt;code class=&quot;highlighter-rouge&quot;&gt;boolean&lt;/code&gt;外，其它的全部为&lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有了以上几点，那我们如下定义后台。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;接收&lt;code class=&quot;highlighter-rouge&quot;&gt;post&lt;/code&gt;数据&lt;/li&gt;
  &lt;li&gt;按收&lt;code class=&quot;highlighter-rouge&quot;&gt;json&lt;/code&gt;格式传入的数据&lt;/li&gt;
  &lt;li&gt;接收数据后，进行数据表的存储操作&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;新建控制器&quot;&gt;新建控制器&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/SpringMVC/assets/image/chapter2/13.png&quot; alt=&quot;new controller&quot; /&gt;&lt;/p&gt;

&lt;p&gt;自动装入&lt;code class=&quot;highlighter-rouge&quot;&gt;TeacherRepository&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
@RestController
public class TeacherController {
    @Autowired
    private TeacherRepository teacherRepository;
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;添加方法，并设置路由:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    ...
    // 设置路由
    @RequestMapping(&quot;/teacher/save&quot;)
    public Teacher saveTeacher() {
    }
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;获取请求数据，并装入&lt;code class=&quot;highlighter-rouge&quot;&gt;Teacher&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    ...
    // 设置路由
    @RequestMapping(&quot;/teacher/save&quot;)
    // 使用@RequestBody注解，将请求的`json`数据，直接加载至teacher对象
    public Teacher saveTeacher(@RequestBody Teacher teacher) {
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;打印获取的数据，并执行保存操作:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    ...
    public Teacher saveTeacher(@RequestBody Teacher teacher) {
        // 打印加载的数据
        System.out.println(teacher);

        // 调用保存操作
        return teacherRepository.save(teacher);
    }
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最终的代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.mengyunzhi.controller;

import com.mengyunzhi.repository.Teacher;
import com.mengyunzhi.repository.TeacherRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

/**
 * Created by panjie on 17/4/6.
 */
// 声明为Rest控制器（支持前后台分离）
@RestController
public class TeacherController {
    @Autowired
    private TeacherRepository teacherRepository;

    // 设置路由
    @RequestMapping(&quot;/teacher/save&quot;)
    // 使用@RequestBody注解，将请求的`json`数据，直接加载至teacher对象
    public Teacher saveTeacher(@RequestBody Teacher teacher) {
        // 打印加载的数据
        System.out.println(teacher);

        // 调用保存操作
        return teacherRepository.save(teacher);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h2 id=&quot;测试-1&quot;&gt;测试&lt;/h2&gt;
&lt;p&gt;重新启动应用, 我们可以点击&lt;code class=&quot;highlighter-rouge&quot;&gt;SpringMvcApplication&lt;/code&gt;中&lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt;函数左侧的启动按钮，也可以点击右上角的启动按钮。如果你点击的为右上角按钮，那么需要注意进行切换（这是由于我们刚刚建立过测试类，而测试类也是可以直接启动的）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/SpringMVC/assets/image/chapter2/14.png&quot; alt=&quot;run&quot; /&gt;&lt;/p&gt;

&lt;p&gt;启动&lt;code class=&quot;highlighter-rouge&quot;&gt;postMan&lt;/code&gt;, 并发送请求。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/SpringMVC/assets/image/chapter2/15.png&quot; alt=&quot;post man&quot; /&gt;&lt;/p&gt;

&lt;p&gt;请求结果：
&lt;img src=&quot;/SpringMVC/assets/image/chapter2/16.png&quot; alt=&quot;post man&quot; /&gt;&lt;/p&gt;

&lt;p&gt;控制台信息：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Teacher{id=null, name='zhangsan', email='zhangsan@yunzhiclub.com', address='scse of hebut', sex=false}
Hibernate: insert into teacher (address, email, name, sex) values (?, ?, ?, ?)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;此时，我们看到了&lt;code class=&quot;highlighter-rouge&quot;&gt;insert&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;sql&lt;/code&gt;语句，至此，基本确认数据已经被成功增加到数据库了，如果你还不放心，可以打开&lt;code class=&quot;highlighter-rouge&quot;&gt;navicat&lt;/code&gt;来查看并确认一下。&lt;/p&gt;

&lt;p&gt;我们在前面，按照&lt;code class=&quot;highlighter-rouge&quot;&gt;Teacher&lt;/code&gt;构造函数中，变量的顺序使用&lt;code class=&quot;highlighter-rouge&quot;&gt;postman&lt;/code&gt;将变量按顺序一一进行了传入。那么是否可以改变变量传入的顺序呢？比如说，我们将请求的&lt;code class=&quot;highlighter-rouge&quot;&gt;json&lt;/code&gt;数据变更为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;address&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;scse of hebut&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;LISI&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;email&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;zhangsan@yunzhiclub.com&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;sex&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;尝试并总结一下它的规律吧。&lt;/p&gt;

&lt;h1 id=&quot;pagingandsortingrepository&quot;&gt;PagingAndSortingRepository&lt;/h1&gt;
&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;以下内容后期将迁入至其它章节，本节请直接略过&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CrudRepository&lt;/code&gt;只能实现基本的增查改删，大多数的时候，我们还需要对数据进行分页、排序。强大的&lt;code class=&quot;highlighter-rouge&quot;&gt;Spring&lt;/code&gt;当然想到了这点– &lt;code class=&quot;highlighter-rouge&quot;&gt;PagingAndSortingRepository&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在官方文档中，我们看到是这样介绍&lt;code class=&quot;highlighter-rouge&quot;&gt;PagingAndSortingRepository&lt;/code&gt;的:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface PagingAndSortingRepository&amp;lt;T, ID extends Serializable&amp;gt;
  extends CrudRepository&amp;lt;T, ID&amp;gt; {

  Iterable&amp;lt;T&amp;gt; findAll(Sort sort);

  Page&amp;lt;T&amp;gt; findAll(Pageable pageable);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;是的，正如我们看到的一样：&lt;code class=&quot;highlighter-rouge&quot;&gt;PagingAndSortingRepository&lt;/code&gt;继承了&lt;code class=&quot;highlighter-rouge&quot;&gt;CrudRepository&lt;/code&gt;，因而&lt;code class=&quot;highlighter-rouge&quot;&gt;PagingAndSortingRepository&lt;/code&gt;具有&lt;code class=&quot;highlighter-rouge&quot;&gt;CrudRepository&lt;/code&gt;的全部功能，并且在此之上，补充了两个用于排序和分页的功能。&lt;/p&gt;</content><author><name>潘杰</name></author><summary type="html">和我们以前学习的框架基本一致，框架已经为我们封装好了大部分的基本操作，我们只需要做适当的继承操作就可以实现大部的数据操作了。</summary></entry><entry><title type="html">第三节：创建数据表</title><link href="http://localhost:4000/SpringMVC/chapter2/create-tabel/" rel="alternate" type="text/html" title="第三节：创建数据表" /><published>2017-04-05T15:22:52+08:00</published><updated>2017-04-05T15:22:52+08:00</updated><id>http://localhost:4000/SpringMVC/chapter2/create-tabel</id><content type="html" xml:base="http://localhost:4000/SpringMVC/chapter2/create-tabel/">&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SpringMVC&lt;/code&gt;中集成了&lt;code class=&quot;highlighter-rouge&quot;&gt;hibernate&lt;/code&gt;框架，所以在&lt;code class=&quot;highlighter-rouge&quot;&gt;SrpingMVC&lt;/code&gt;,有关关系型数据库的部分，我们完全可以参考&lt;code class=&quot;highlighter-rouge&quot;&gt;hibernate&lt;/code&gt;的开发文档。&lt;code class=&quot;highlighter-rouge&quot;&gt;hibernate&lt;/code&gt;为我们提供了这样一个功能：将带有相关注解的&lt;code class=&quot;highlighter-rouge&quot;&gt;java&lt;/code&gt;类自动与&lt;code class=&quot;highlighter-rouge&quot;&gt;数据表&lt;/code&gt;进行关系。从而使我们可以完全的使用&lt;code class=&quot;highlighter-rouge&quot;&gt;java&lt;/code&gt;代码来定义数据表。这样的做的优点当然很多，对于我们而言，我们再也不需要为了数据表不统一造成的各种莫名&lt;code class=&quot;highlighter-rouge&quot;&gt;BUG&lt;/code&gt;而烦恼了。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;JPA&lt;/code&gt;全称&lt;code class=&quot;highlighter-rouge&quot;&gt;Java Persistence API&lt;/code&gt;.&lt;code class=&quot;highlighter-rouge&quot;&gt;JPA&lt;/code&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;JDK 5.0&lt;/code&gt;注解或&lt;code class=&quot;highlighter-rouge&quot;&gt;XML&lt;/code&gt;描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中。&lt;a href=&quot;http://baike.baidu.com/item/JPA&quot;&gt;http://baike.baidu.com/item/JPA&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;新建实体类&quot;&gt;新建实体类&lt;/h1&gt;
&lt;p&gt;我们新建&lt;code class=&quot;highlighter-rouge&quot;&gt;repository&lt;/code&gt;包，并在该包中，新建&lt;code class=&quot;highlighter-rouge&quot;&gt;Teacher&lt;/code&gt;类。
&lt;img src=&quot;/SpringMVC/assets/image/chapter2/3.png&quot; alt=&quot;new table&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;@Entity&lt;/code&gt;来说明该类对应一个数据表,数据表的名字与类名相同。&lt;/li&gt;
  &lt;li&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;@Id&lt;/code&gt;来说明：此字段是该表的主键。&lt;/li&gt;
  &lt;li&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;@GeneratedValue(strategy = GenerationType.AUTO)&lt;/code&gt;来说明：该主键的生成策略为自动，对应MySQL的属性为’Auto increment’&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;只所以要将上述3个注解单独拿出来，是因为以为我们要常与它们打交道。每新建一个实体，上述的操作都是必须的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.mengyunzhi.repository;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;

/**
 * Created by panjie on 17/4/5.
 */
// 使用@Entity 来说明该类对应一个数据表
@Entity
public class Teacher {
    //    声明主键
    @Id
    //    声明主键生成策略为 自动
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h2 id=&quot;测试&quot;&gt;测试&lt;/h2&gt;
&lt;p&gt;我们再次点击&lt;code class=&quot;highlighter-rouge&quot;&gt;IDEA&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;Run&lt;/code&gt;按钮，来重新启动项目。项目成功启动后，我们将得到一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Teacher&lt;/code&gt;表，这个表中，有一个字段&lt;code class=&quot;highlighter-rouge&quot;&gt;id&lt;/code&gt;，该字段为表的主键，该字段被设置了&lt;code class=&quot;highlighter-rouge&quot;&gt;Auto increment&lt;/code&gt;属性。如下：
&lt;img src=&quot;/SpringMVC/assets/image/chapter2/4.png&quot; alt=&quot;edit table&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;增加其它属性&quot;&gt;增加其它属性&lt;/h1&gt;
&lt;p&gt;参考&lt;code class=&quot;highlighter-rouge&quot;&gt;ER&lt;/code&gt;图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/SpringMVC/assets/image/chapter2/6.png&quot; alt=&quot;Logical model&quot; /&gt; 
&lt;img src=&quot;/SpringMVC/assets/image/chapter2/7.png&quot; alt=&quot;physical model&quot; /&gt;&lt;/p&gt;

&lt;p&gt;定制JAVA代码:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.mengyunzhi.repository;

import javax.persistence.*;

/**
 * Created by panjie on 17/4/5.
 */
// 使用@Entity 来说明该类对应一个数据表
@Entity
public class Teacher {
    //    声明主键
    @Id
    //    声明主键生成策略为 自动
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
    @Column(length = 25)    // 声明字段的长度为25
    private String name;    // 姓名
    @Column(length = 50)
    private String email;   // 邮箱
    private String address; // 地址. 不进行@Column声明，则默认长度为255
    private Boolean sex;    // 性别：0，男。1，女.
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;然后我们重新启动项目，将得到拥有如下类型的数据表:
&lt;img src=&quot;/SpringMVC/assets/image/chapter2/5.png&quot; alt=&quot;edit table&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后，按照&lt;code class=&quot;highlighter-rouge&quot;&gt;jpa&lt;/code&gt;的规范，我们增加&lt;code class=&quot;highlighter-rouge&quot;&gt;set\get&lt;/code&gt;函数，构造函数及&lt;code class=&quot;highlighter-rouge&quot;&gt;toString&lt;/code&gt;函数。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;你可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl&lt;/code&gt;+&lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;来快速生成上面所提到的函数。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;最终完整代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.mengyunzhi.repository;

import javax.persistence.*;

/**
 * Created by panjie on 17/4/5.
 */
// 使用@Entity 来说明该类对应一个数据表
@Entity
public class Teacher {
    //    声明主键
    @Id
    //    声明主键生成策略为 自动
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
    @Column(length = 25)            // 声明字段的长度为25
    private String name = &quot;&quot;;       // 姓名
    @Column(length = 50)
    private String email = &quot;&quot;;      // 邮箱
    private String address = &quot;&quot;;    // 地址. 不进行@Column声明，则默认长度为255
    private Boolean sex = false;    // 性别：false(0)，男。true(1)，女.

    public void setId(Long id) {
        this.id = id;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    public void setSex(Boolean sex) {
        this.sex = sex;
    }

    public Long getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String getEmail() {
        return email;
    }

    public String getAddress() {
        return address;
    }

    public Boolean getSex() {
        return sex;
    }

    public Teacher(String name, String email, String address, Boolean sex) {
        this.name = name;
        this.email = email;
        this.address = address;
        this.sex = sex;
    }

    public Teacher() {
    }

    @Override
    public String toString() {
        return &quot;Teacher{&quot; +
                &quot;id=&quot; + id +
                &quot;, name='&quot; + name + '\'' +
                &quot;, email='&quot; + email + '\'' +
                &quot;, address='&quot; + address + '\'' +
                &quot;, sex=&quot; + sex +
                '}';
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;最后，我们重新运行项目，以确保未发生拼写错误。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://docs.jboss.org/hibernate/orm/current/userguide/html_single/Hibernate_User_Guide.html#basic-provided&quot;&gt;官方文档：java 与 数据表类型对照&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>潘杰</name></author><summary type="html">SpringMVC中集成了hibernate框架，所以在SrpingMVC,有关关系型数据库的部分，我们完全可以参考hibernate的开发文档。hibernate为我们提供了这样一个功能：将带有相关注解的java类自动与数据表进行关系。从而使我们可以完全的使用java代码来定义数据表。这样的做的优点当然很多，对于我们而言，我们再也不需要为了数据表不统一造成的各种莫名BUG而烦恼了。</summary></entry><entry><title type="html">第二节：添加jpa、mysql模块</title><link href="http://localhost:4000/SpringMVC/chapter2/add-jpa-and-mysql/" rel="alternate" type="text/html" title="第二节：添加jpa、mysql模块" /><published>2017-04-05T14:47:23+08:00</published><updated>2017-04-05T14:47:23+08:00</updated><id>http://localhost:4000/SpringMVC/chapter2/add-jpa-and-mysql</id><content type="html" xml:base="http://localhost:4000/SpringMVC/chapter2/add-jpa-and-mysql/">&lt;p&gt;如果在项目刚刚生成时，你查看过生成项目的目录信息，不难发现我们在前面选择过一个叫做&lt;code class=&quot;highlighter-rouge&quot;&gt;web&lt;/code&gt;的Spring核心模块，被写入了根目录下的&lt;code class=&quot;highlighter-rouge&quot;&gt;pom.xml&lt;/code&gt;中。&lt;/p&gt;

&lt;p&gt;即如下代码：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这是&lt;code class=&quot;highlighter-rouge&quot;&gt;SpringMVC&lt;/code&gt;的核心模块。本章中，我们将使用&lt;code class=&quot;highlighter-rouge&quot;&gt;mysql&lt;/code&gt;做为后台的数据库。此时，我们需要加入&lt;code class=&quot;highlighter-rouge&quot;&gt;jpa&lt;/code&gt;模块来说明:本项目是需要关系型数据库来支撑的；我们需要加入&lt;code class=&quot;highlighter-rouge&quot;&gt;mysql&lt;/code&gt;模块，来说明：本项目使用的关系型数据库的类型为&lt;code class=&quot;highlighter-rouge&quot;&gt;mysql&lt;/code&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在本教程中，我们仍然使用XAMPP中集成的&lt;code class=&quot;highlighter-rouge&quot;&gt;mysql&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们首先启动&lt;code class=&quot;highlighter-rouge&quot;&gt;xampp&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;mysql&lt;/code&gt;服务，并使用&lt;code class=&quot;highlighter-rouge&quot;&gt;navicat&lt;/code&gt;来建立本项目要使用的数据库: &lt;code class=&quot;highlighter-rouge&quot;&gt;springmvc&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/SpringMVC/assets/image/chapter2/1.png&quot; alt=&quot;new database springmvc&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;加入jpa模块&quot;&gt;加入JPA模块&lt;/h1&gt;
&lt;p&gt;我们打开&lt;code class=&quot;highlighter-rouge&quot;&gt;/pom.xml&lt;/code&gt;文件的如下代码段:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;增加&lt;code class=&quot;highlighter-rouge&quot;&gt;JPA&lt;/code&gt;模块后：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-data-jpa&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;重新导入依赖模块:
&lt;img src=&quot;/SpringMVC/assets/image/chapter2/2.png&quot; alt=&quot;new database springmvc&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在导入过程中,&lt;code class=&quot;highlighter-rouge&quot;&gt;IDEA&lt;/code&gt;最下侧将有导入进度的提示。未报错，则导入成功。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;[注意]&lt;/strong&gt; 当&lt;code class=&quot;highlighter-rouge&quot;&gt;pom.xml&lt;/code&gt;第一次变化时，&lt;code class=&quot;highlighter-rouge&quot;&gt;idea&lt;/code&gt;在右下角会弹出重新导入依赖模块的提示，我们可以进行点击导入，也可以点击提示中的”auto import”,这样在下次&lt;code class=&quot;highlighter-rouge&quot;&gt;pom.xml&lt;/code&gt;变化时，将自动触发&lt;code class=&quot;highlighter-rouge&quot;&gt;maven&lt;/code&gt;的重新导入命令.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;参考官方文档: &lt;a href=&quot;https://spring.io/guides/gs/accessing-data-jpa/&quot;&gt;https://spring.io/guides/gs/accessing-data-jpa/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;加入mysql模块&quot;&gt;加入mysql模块&lt;/h1&gt;
&lt;p&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;jpa&lt;/code&gt;的步骤相似，我们用同样的方法，加入&lt;code class=&quot;highlighter-rouge&quot;&gt;mysql&lt;/code&gt;模块，并重新导入该模块。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--jpa 模块：关系型数据库--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-data-jpa&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--数据库类型：mysql--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;重新导入依赖模块略。&lt;/p&gt;

&lt;h1 id=&quot;测试&quot;&gt;测试&lt;/h1&gt;
&lt;p&gt;我们点击右上角的运行按钮：
&lt;img src=&quot;/SpringMVC/assets/image/chapter1/9.png&quot; alt=&quot;run project&quot; /&gt;并查看&lt;code class=&quot;highlighter-rouge&quot;&gt;IDEA&lt;/code&gt;下侧的控制台，将得到如下的错误提示。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;***************************
APPLICATION FAILED TO START
***************************

Description:

Cannot determine embedded database driver class for database type NONE
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这是&lt;code class=&quot;highlighter-rouge&quot;&gt;jpa&lt;/code&gt;模块给我们的一个提示，它在说，虽然我已经启动了，但是你没有告诉我要连接的数据库类型是什么。当然了，除了要告诉它要连接的数据库类型(mysql)以外，我们还需要告诉它要连接的数据名称是什么，对应的用户名和密码又都是什么。&lt;/p&gt;

&lt;h2 id=&quot;配置jpa&quot;&gt;配置JPA&lt;/h2&gt;
&lt;p&gt;打开，&lt;code class=&quot;highlighter-rouge&quot;&gt;/src/main/resources/application.properties&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;配置以下信息：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 在项目初始化时，重新创建数据表
spring.jpa.hibernate.ddl-auto=create
# 指定连接的类型为mysql 连接的地址为：localhost 端口为3306 ，数据为springmvc
spring.datasource.url=jdbc:mysql://localhost:3306/springmvc
# 用户名为root
spring.datasource.username=root
# 密码为空
spring.datasource.password=
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/SpringMVC/assets/image/chapter2/8.png&quot; alt=&quot;new database springmvc&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此时，我们再次启动项目，在&lt;code class=&quot;highlighter-rouge&quot;&gt;mysql&lt;/code&gt;服务启动的前提下，将得到启动成功的提示:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;2017-04-05 15:16:17.776  INFO 4627 --- [           main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 8080 (http)
2017-04-05 15:16:17.782  INFO 4627 --- [           main] com.mengyunzhi.SpringMvcApplication      : Started SpringMvcApplication in 6.929 seconds (JVM running for 7.965)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;参考官方文档：&lt;a href=&quot;https://spring.io/guides/gs/accessing-data-mysql/&quot;&gt;https://spring.io/guides/gs/accessing-data-mysql/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>潘杰</name></author><summary type="html">如果在项目刚刚生成时，你查看过生成项目的目录信息，不难发现我们在前面选择过一个叫做web的Spring核心模块，被写入了根目录下的pom.xml中。</summary></entry><entry><title type="html">第一节：ER图</title><link href="http://localhost:4000/SpringMVC/chapter2/er-diagram/" rel="alternate" type="text/html" title="第一节：ER图" /><published>2017-04-05T14:26:57+08:00</published><updated>2017-04-05T14:26:57+08:00</updated><id>http://localhost:4000/SpringMVC/chapter2/er-diagram</id><content type="html" xml:base="http://localhost:4000/SpringMVC/chapter2/er-diagram/">&lt;p&gt;和以前的我们接触到的教程一下，在教师管理中，我们也会按照增查改删（CRUD）的顺序，来进行程序的开发。
在进行数据的增加操作前，我们参照的ER图如下。&lt;/p&gt;

&lt;p&gt;逻辑模型：
&lt;img src=&quot;/SpringMVC/assets/image/chapter2/6.png&quot; alt=&quot;Logical model&quot; /&gt;&lt;/p&gt;

&lt;p&gt;物理模型：
&lt;img src=&quot;/SpringMVC/assets/image/chapter2/7.png&quot; alt=&quot;physical model&quot; /&gt;&lt;/p&gt;</content><author><name>潘杰</name></author><summary type="html">和以前的我们接触到的教程一下，在教师管理中，我们也会按照增查改删（CRUD）的顺序，来进行程序的开发。 在进行数据的增加操作前，我们参照的ER图如下。</summary></entry><entry><title type="html">第五节：HelloWorld</title><link href="http://localhost:4000/SpringMVC/chapter1/5-hello-world/" rel="alternate" type="text/html" title="第五节：HelloWorld" /><published>2017-04-01T15:55:20+08:00</published><updated>2017-04-01T15:55:20+08:00</updated><id>http://localhost:4000/SpringMVC/chapter1/5-hello-world</id><content type="html" xml:base="http://localhost:4000/SpringMVC/chapter1/5-hello-world/">&lt;h1 id=&quot;建立c层&quot;&gt;建立C层&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;建立第一个包，控制器&lt;code class=&quot;highlighter-rouge&quot;&gt;controller&lt;/code&gt;: 在&lt;code class=&quot;highlighter-rouge&quot;&gt;com.mengyunzhi&lt;/code&gt;上点击右键，选择&lt;code class=&quot;highlighter-rouge&quot;&gt;package&lt;/code&gt;, 然后输入&lt;code class=&quot;highlighter-rouge&quot;&gt;controller&lt;/code&gt; -&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;ok&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;controller&lt;/code&gt;上点右键，新建一个&lt;code class=&quot;highlighter-rouge&quot;&gt;java class&lt;/code&gt;, 文件名为&lt;code class=&quot;highlighter-rouge&quot;&gt;HelloController&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/SpringMVC/assets/image/chapter1/12.png&quot; alt=&quot;new Hello class&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;上述文件名及类名有误，应该为HelloController. todo:修正截图。&lt;/p&gt;

&lt;p&gt;然后&lt;b&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;RestController&lt;/code&gt;注解来说明该类是一个控制器。&lt;/b&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.mengyunzhi.controller;

import org.springframework.web.bind.annotation.RestController;

/**
 * Created by panjie on 17/4/1.
 */
@RestController
public class HelloController {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;在SpringMVC中，将大量的来使用注解&lt;code class=&quot;highlighter-rouge&quot;&gt;@&lt;/code&gt;来进行声明。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;新建-funciton&quot;&gt;新建 funciton&lt;/h1&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.mengyunzhi.controller;
...
@Controller
public class HelloController {

    public String world() {
        return &quot;Hello World!&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;b&gt; 使用&lt;code class=&quot;highlighter-rouge&quot;&gt;RequestMapping&lt;/code&gt;注解来声明该方法是一个触发器，并设置该触发器对应的路由信息.&lt;/b&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.mengyunzhi.controller;
...
import org.springframework.web.bind.annotation.RequestMapping;
...
    // 设置该方法为一个触发器，并设置该触发器对应的路由信息&quot;/&quot;
    @RequestMapping(&quot;/&quot;)
    public String world() {
        return &quot;Hello World!&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最后，我们点击控制台左上角的重启按钮，重新启动应用（重新进行编译）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/SpringMVC/assets/image/chapter1/13.png&quot; alt=&quot;rerun&quot; /&gt;&lt;/p&gt;

&lt;p&gt;IDEA在编写的过程中，没有提示错误，且启动时控制台无报错信息，则说明代码正确。&lt;/p&gt;

&lt;h1 id=&quot;测试&quot;&gt;测试&lt;/h1&gt;
&lt;p&gt;此时，我们打开浏览器，输入:&lt;code class=&quot;highlighter-rouge&quot;&gt;http://127.0.0.1:8080/&lt;/code&gt;
将得到如下界面。
&lt;img src=&quot;/SpringMVC/assets/image/chapter1/14.png&quot; alt=&quot;hello world&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结：&lt;/h3&gt;
&lt;p&gt;没错，在强大的idea的帮助下，搭建一个SpringMVC API后台接口环境，就是如此的简单。&lt;/p&gt;</content><author><name>潘杰</name></author><summary type="html">建立C层 建立第一个包，控制器controller: 在com.mengyunzhi上点击右键，选择package, 然后输入controller -&amp;gt; ok 在controller上点右键，新建一个java class, 文件名为HelloController</summary></entry></feed>